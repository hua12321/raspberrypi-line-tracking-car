# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SCkATnXl4w8AsKaGYieJaz55ppCUeL0T
"""

#!/usr/bin/env python3
"""
Line Following Car with Raspberry Pi
This script implements a line-following robot using a Raspberry Pi 4B, PiCamera,
HSV color segmentation, PID control, and shape detection.
"""

import time
import cv2
import numpy as np
import RPi.GPIO as GPIO
from picamera2 import Picamera2


# === GPIO Configuration ===
ENA = 22
ENB = 26
LEFT_MOTOR_FORWARD = 5
LEFT_MOTOR_BACKWARD = 6
RIGHT_MOTOR_FORWARD = 13
RIGHT_MOTOR_BACKWARD = 19

# Initialize GPIO
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)
GPIO.setup(
    [LEFT_MOTOR_FORWARD, LEFT_MOTOR_BACKWARD,
     RIGHT_MOTOR_FORWARD, RIGHT_MOTOR_BACKWARD,
     ENA, ENB],
    GPIO.OUT
)

# PWM Setup
FREQUENCY = 700
left_fwd = GPIO.PWM(LEFT_MOTOR_FORWARD, FREQUENCY)
left_bwd = GPIO.PWM(LEFT_MOTOR_BACKWARD, FREQUENCY)
right_fwd = GPIO.PWM(RIGHT_MOTOR_FORWARD, FREQUENCY)
right_bwd = GPIO.PWM(RIGHT_MOTOR_BACKWARD, FREQUENCY)
ena_pwm = GPIO.PWM(ENA, FREQUENCY)
enb_pwm = GPIO.PWM(ENB, FREQUENCY)

for pwm in (left_fwd, left_bwd, right_fwd, right_bwd, ena_pwm, enb_pwm):
    pwm.start(0)
ena_pwm.ChangeDutyCycle(100)
enb_pwm.ChangeDutyCycle(100)

# Control Parameters
MAX_SPEED = 60
MIN_SPEED = 20
TURN_SPEED = 50
TURN_THRESHOLD = 50
Kp, Ki, Kd =0.5, 0.01, 0.2
prev_error, integral = 0.0, 0.0

# HSV Color Ranges
COLOR_RANGES = {
    "black": [(0, 179, 0, 102, 0, 66)],
    "blue": [(0, 16, 0, 255, 64, 255)],  # Removed duplicate 'blue' key
    "green": [(34, 67, 167, 255, 111, 179)],
    "yellow": [(82, 110, 36, 255, 172, 255)],
    "red": [(109, 134, 188, 255, 88, 255)]
}

# Camera Initialization
picam2 = Picamera2()
picam2.preview_configuration.main.size = (320, 240)
picam2.preview_configuration.main.format = "RGB888"
picam2.preview_configuration.controls.FrameRate = 30
picam2.configure("preview")
picam2.start()
time.sleep(2)  # Allow camera to warm up


# === Functions ===

def detect_shapes_arrows(frame, min_area=400):
    """Detect shapes and arrows in the frame using contour analysis.

    Args:
        frame (np.ndarray): Input RGB image frame.
        min_area (int): Minimum contour area to consider (default: 400).
    """
    gray = cv2.cvtColor(frame, cv2.COLOR_RGB2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    edges = cv2.Canny(blurred, 50, 150)
    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    for contour in contours:
        area = cv2.contourArea(contour)
        if area < min_area:
            continue
        approx = cv2.approxPolyDP(contour, 0.02 * cv2.arcLength(contour, True), True)
        shape = None
        if len(approx) == 3:
            shape = "Triangle"
        elif len(approx) == 4:
            shape = "Rectangle"
        elif len(approx) == 5:
            shape = "Pentagon"
        elif len(approx) == 6:
            shape = "Hexagon"
        else:
            (x, y), radius = cv2.minEnclosingCircle(contour)
            circle_area = np.pi * radius * radius
            if 0.9 * circle_area <= area <= 1.1 * circle_area:
                shape = "Circle"
            elif 0.6 * circle_area <= area <= 0.8 * circle_area:
                shape = "3/4 Circle"
        if shape:
            cv2.drawContours(frame, [approx], -1, (0, 255, 0), 2)
            cv2.putText(frame, shape, tuple(approx[0][0]), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
            print(f"Detected shape: {shape}")

    for contour in contours:
        approx = cv2.approxPolyDP(contour, 0.03 * cv2.arcLength(contour, True), True)
        if 5 <= len(approx) <= 8:
            M = cv2.moments(contour)
            if M["m00"] == 0:
                continue
            cx = int(M["m10"] / M["m00"])
            cy = int(M["m01"] / M["m00"])
            x, y, w, h = cv2.boundingRect(approx)
            ar = w / float(h)
            container = "Rectangle with arrow inside" if 0.8 <= ar <= 1.2 else "Circle with arrow inside"
            cv2.drawContours(frame, [approx], -1, (255, 0, 0), 2)
            cv2.putText(frame, container, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 0, 0), 2)
            print(f"Detected arrow: {container}")


def get_mask(hsv, color):
    """Generate a binary mask for a specific color in HSV space.

    Args:
        hsv (np.ndarray): HSV image frame.
        color (str): Color to mask (e.g., 'red', 'yellow').

    Returns:
        np.ndarray: Binary mask.
    """
    ranges = COLOR_RANGES[color]
    if color == "red":
        mask1 = cv2.inRange(hsv, np.array([ranges[0][0], ranges[0][2], ranges[0][4]]),
                            np.array([ranges[0][1], ranges[0][3], ranges[0][5]]))
        mask2 = cv2.inRange(hsv, np.array([ranges[1][0], ranges[1][2], ranges[1][4]]),
                            np.array([ranges[1][1], ranges[1][3], ranges[1][5]]))
        return cv2.bitwise_or(mask1, mask2)
    r = ranges[0]
    return cv2.inRange(hsv, np.array([r[0], r[2], r[4]]), np.array([r[1], r[3], r[5]]))


def find_line(mask):
    """Find the centroid of the line in the mask.

    Args:
        mask (np.ndarray): Binary mask of the line.

    Returns:
        int or None: x-coordinate of the centroid, or None if no line is found.
    """
    roi = mask[120:240, :]
    contours, _ = cv2.findContours(roi, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not contours:
        return None
    c = max(contours, key=cv2.contourArea)
    M = cv2.moments(c)
    if M["m00"] == 0:
        return None
    return int(M["m10"] / M["m00"])


def calculate_pid(error, prev_error, integral):
    """Calculate the PID correction value.

    Args:
        error (float): Current error between line centroid and image center.
        prev_error (float): Previous error value.
        integral (float): Accumulated error.

    Returns:
        tuple: (correction, new_prev_error, new_integral)
    """
    derivative = error - prev_error
    corr = KP * error + KI * integral + KD * derivative
    return corr, error, integral + error


def control_motors(cx, width):
    """Control the motors based on the detected line position using a PID controller.

    Args:
        cx (int): The x-coordinate of the detected line's centroid.
        width (int): The width of the image frame.
    """
    global prev_error, integral
    center = width // 2
    if cx is None:
        left_fwd.ChangeDutyCycle(0)
        right_fwd.ChangeDutyCycle(0)
        left_bwd.ChangeDutyCycle(30)
        right_bwd.ChangeDutyCycle(30)
        ena_pwm.ChangeDutyCycle(30)
        enb_pwm.ChangeDutyCycle(30)
        time.sleep(0.8)
        left_bwd.ChangeDutyCycle(0)
        right_bwd.ChangeDutyCycle(0)
        ena_pwm.ChangeDutyCycle(0)
        enb_pwm.ChangeDutyCycle(0)
        return
    error = cx - center
    if abs(error) > TURN_THRESHOLD:
        if error > 0:
            left_bwd.ChangeDutyCycle(TURN_SPEED)
            right_fwd.ChangeDutyCycle(TURN_SPEED)
        else:
            left_fwd.ChangeDutyCycle(TURN_SPEED)
            right_bwd.ChangeDutyCycle(TURN_SPEED)
        ena_pwm.ChangeDutyCycle(TURN_SPEED)
        enb_pwm.ChangeDutyCycle(TURN_SPEED)
        return
    corr, prev_error, integral = calculate_pid(error, prev_error, integral)
    ls = max(min(MAX_SPEED - corr, MAX_SPEED), MIN_SPEED)
    rs = max(min(MAX_SPEED + corr, MAX_SPEED), MIN_SPEED)
    left_fwd.ChangeDutyCycle(ls)
    right_fwd.ChangeDutyCycle(rs)
    left_bwd.ChangeDutyCycle(0)
    right_bwd.ChangeDutyCycle(0)
    ena_pwm.ChangeDutyCycle(ls)
    enb_pwm.ChangeDutyCycle(rs)


def select_colors():
    """Prompt user to select two colors for line following.

    Returns:
        tuple: (color1, color2) - The selected colors.
    """
    print("Available colors: red, green, yellow, blue")
    color1 = input("Enter first color to follow: ").strip().lower()
    color2 = input("Enter second color to follow: ").strip().lower()
    if color1 not in COLOR_RANGES or color2 not in COLOR_RANGES:
        print("Invalid colors. Defaulting to red and green.")
        return "red", "green"
    return color1, color2


# === Main Loop ===
color1, color2 = select_colors()
print(f"Following colors: {color1}, {color2} (and black by default)")

try:
    while True:
        frame = picam2.capture_array()
        hsv = cv2.cvtColor(frame, cv2.COLOR_RGB2HSV)

        mask1 = get_mask(hsv, color1)
        mask2 = get_mask(hsv, color2)
        maskb = get_mask(hsv, "black")

        mask_display = maskb
        if find_line(mask1) is not None:
            mask_display = mask1
        elif find_line(mask2) is not None:
            mask_display = mask2

        cv2.imshow("Current Mask", mask_display)
        cv2.imshow("Mask1", mask1)
        cv2.imshow("Mask2", mask2)
        cv2.imshow("Mask Black", maskb)

        cx = find_line(mask1)
        if cx is not None:
            line = color1
        else:
            cx = find_line(mask2)
            if cx is not None:
                line = color2
            else:
                cx = find_line(maskb)
                line = "black"
        control_motors(cx, frame.shape[1])

        detect_shapes_arrows(frame)
        cv2.imshow("Camera View", frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

except KeyboardInterrupt:
    print("Exiting...")

finally:
    for pwm in (left_fwd, left_bwd, right_fwd, right_bwd, ena_pwm, enb_pwm):
        pwm.stop()
    GPIO.cleanup()
    picam2.close()
    cv2.destroyAllWindows()